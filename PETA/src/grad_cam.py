# -*- coding: utf-8 -*-
from __future__ import print_function, division
"""MuestraFull3700_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dR7ZG17_Mmr3y3JV0mLf12Bp8U8J27Aa
"""

import sys

try:
    from google.colab import drive
    drive.mount('/content/gdrive')
except ModuleNotFoundError:
    print('Not running on Google')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import cv2
import os
import time
import copy
import torch
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import Dataset, DataLoader
import torchvision
from torchvision import transforms, utils, models, datasets
import torch.nn as nn
import torch.optim as optim
import nibabel as nib
import scipy.ndimage as ndi
from pathlib import Path
from PIL import Image
import io
import json
import random
import sklearn.metrics
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score
from matplotlib import pyplot
import json
from torchinfo import summary

# CAM
from pytorch_grad_cam import GradCAM, HiResCAM, ScoreCAM, GradCAMPlusPlus, AblationCAM, XGradCAM, EigenCAM, FullGrad
from pytorch_grad_cam.utils.model_targets import ClassifierOutputTarget
#from pytorch_grad_cam.utils.image import show_cam_on_image
from pytorch_grad_cam import GuidedBackpropReLUModel
from pytorch_grad_cam.utils.image import show_cam_on_image, \
    deprocess_image, \
    preprocess_image


# Devuelve un array 1x512x512 con las intensidades de la m√°scara de gradCAM
# En rango [0,255]
def generateGradCAMMask(model_ft, inputTensor, target_layers):
    cam = GradCAM(model=model_ft, target_layers=target_layers, use_cuda= False)

    # targets = [ClassifierOutputTarget(1)]
    targets = None
    
    # You can also pass aug_smooth=True and eigen_smooth=True, to apply smoothing.
    grayscale_cam = cam(input_tensor=inputTensor, targets=targets)

    return grayscale_cam

def generateGradCAM(model_ft, studyID, inputTensor, layerNames, outputFolder = '.'):
    # rgb_img = np.zeros(shape=(512, 512, 3), dtype=float)

    rgb_img = inputTensor[0].clone().detach().cpu().numpy()

    # # Normalization [0,1], required by show_cam_on_image
    rgb_img = (rgb_img - np.min(rgb_img))/np.ptp(rgb_img)

    rgb_img = np.transpose( rgb_img, (1,2,0)) # Channels should be at the end

    print("Generating GradCAM for", layerNames)
    target_layers = list(map( lambda layerName: getattr(model_ft, layerName), layerNames))

    grayscale_cam = generateGradCAMMask(model_ft, inputTensor, target_layers)

    # In this example grayscale_cam has only one image in the batch:
    grayscale_cam = grayscale_cam[0, :]
    cam_image = show_cam_on_image(rgb_img, grayscale_cam, use_rgb=True)
    cam_image = cv2.cvtColor(cam_image, cv2.COLOR_RGB2BGR)
   
    PIL_image = Image.fromarray((rgb_img * 255).astype('uint8'), 'RGB')

    imgPrefix = studyID + "_" +  ",".join(layerNames)

    PIL_image.save(os.path.join(outputFolder, studyID + '_original.png'))

    gb_model = GuidedBackpropReLUModel(model=model_ft, use_cuda=False)
    gb = gb_model(inputTensor, target_category=None)

    cam_mask = cv2.merge([grayscale_cam, grayscale_cam, grayscale_cam])
    cam_gb = deprocess_image(cam_mask * gb)
    gb = deprocess_image(gb)

    method = imgPrefix + '_grad'
    cv2.imwrite(os.path.join(outputFolder, f'{method}_cam.jpg'), cam_image)
    cv2.imwrite(os.path.join(outputFolder, f'{method}_gb.jpg'), gb)
    cv2.imwrite(os.path.join(outputFolder, f'{method}_cam_gb.jpg'), cam_gb)
